<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mi Agenda</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
    <div class="fecha-actual-inicio" id="fechaActualDisplay"></div>

    <form id="tareaForm">
        <input type="text" id="tareaInput" placeholder="Añadir una nueva tarea..." required>
        <input type="time" id="horaInput">
        <button type="submit" class="boton">Guardar Tarea</button>
    </form>

    <h2>Tareas pendientes:</h2>
    <ul id="tareasPendientesList">
        <li class="mensaje-info">Cargando tareas...</li>
    </ul>

    <h2>Tareas completadas:</h2>
    <ul id="tareasCompletadasList">
        <li class="mensaje-info">Cargando tareas completadas...</li>
    </ul>

    <div class="navigation">
        <a href="/" class="boton">Volver al Inicio</a>
        <a href="/calendario" class="boton">Calendario</a>
        <a href="/registros_importantes" class="boton">Registros Importantes</a>
    </div>

    <script>
        const fechaActualDisplay = document.getElementById('fechaActualDisplay');
        const tareaInput = document.getElementById('tareaInput');
        const horaInput = document.getElementById('horaInput');
        const tareaForm = document.getElementById('tareaForm');
        const tareasPendientesList = document.getElementById('tareasPendientesList');
        const tareasCompletadasList = document.getElementById('tareasCompletadasList');

        let fechaActual = new Date(); // Usamos esto para la fecha actual de la agenda
        let timeLeftUpdateInterval; // Variable global para el intervalo de actualización

        // Función para formatear la fecha a YYYY-MM-DD
        function formatFecha(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function displayFechaActual() {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            fechaActualDisplay.textContent = fechaActual.toLocaleDateString('es-ES', options);
        }

        async function fetchTareas() {
            const fecha = formatFecha(fechaActual);
            try {
                const response = await fetch(`/api/tareas/${fecha}`);
                const tareas = await response.json();
                renderTareas(tareas);
            } catch (error) {
                console.error('Error al cargar las tareas:', error);
                tareasPendientesList.innerHTML = '<li class="mensaje-info">No se pudieron cargar las tareas.</li>';
                tareasCompletadasList.innerHTML = '';
            }
        }

        function renderTareas(tareas) {
            tareasPendientesList.innerHTML = '';
            tareasCompletadasList.innerHTML = '';

            if (tareas.length === 0) {
                tareasPendientesList.innerHTML = '<li class="no-tasks">No hay tareas para hoy.</li>';
                // Detener el intervalo de actualización si no hay tareas
                if (timeLeftUpdateInterval) {
                    clearInterval(timeLeftUpdateInterval);
                    timeLeftUpdateInterval = null;
                }
                return;
            }

            tareas.sort((a, b) => {
                // Tareas completadas al final
                if (a.completada && !b.completada) return 1;
                if (!a.completada && b.completada) return -1;

                // Luego, por hora (si existe)
                if (a.hora && b.hora) {
                    return a.hora.localeCompare(b.hora);
                }
                if (a.hora) return -1; // Tareas con hora primero
                if (b.hora) return 1;  // Tareas con hora primero
                
                // Si no hay hora, ordenar por texto
                return a.texto.localeCompare(b.texto);
            });

            tareas.forEach(tarea => {
                const li = document.createElement('li');
                li.classList.add('task-item'); // Usamos la misma clase que en calendario.html
                if (tarea.completada) {
                    li.classList.add('completada');
                }
                li.dataset.id = tarea.id;
                li.dataset.fecha = tarea.fecha;
                li.dataset.textoOriginal = tarea.texto;
                li.dataset.horaOriginal = tarea.hora || '';

                // Contenedor principal del texto de la tarea y el tiempo restante
                const taskContentDiv = document.createElement('div');
                taskContentDiv.classList.add('task-content-wrapper');

                // Span para la hora (si existe) y el texto de la tarea
                const taskTextSpan = document.createElement('span');
                taskTextSpan.classList.add('task-text');
                const horaPrefix = tarea.hora ? `<span class="task-time">${tarea.hora}</span> - ` : '';
                taskTextSpan.innerHTML = `${horaPrefix}${tarea.texto}`;

                // Span para el tiempo restante (se llenará en updateTimeLeft)
                const timeLeftSpan = document.createElement('span');
                timeLeftSpan.classList.add('time-left');
                timeLeftSpan.dataset.taskId = tarea.id;       // Importante para encontrarlo en updateTimeLeft
                timeLeftSpan.dataset.taskDate = tarea.fecha;
                timeLeftSpan.dataset.taskTime = tarea.hora || '';

                taskContentDiv.appendChild(taskTextSpan);
                taskContentDiv.appendChild(timeLeftSpan);

                li.appendChild(taskContentDiv);

                // Contenedor de acciones (botones)
                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('task-actions');

                // Botón Completar/Descompletar
                const completeButton = document.createElement('button');
                completeButton.classList.add('btn-completar');
                completeButton.dataset.id = tarea.id;
                if (tarea.completada) {
                    completeButton.textContent = 'Descompletar';
                    completeButton.classList.add('completada');
                } else {
                    completeButton.textContent = 'Completar';
                }
                completeButton.addEventListener('click', toggleTaskCompletada);
                actionsDiv.appendChild(completeButton);

                // Botón Eliminar
                const deleteButton = document.createElement('button');
                deleteButton.classList.add('btn-eliminar');
                deleteButton.dataset.id = tarea.id;
                deleteButton.textContent = 'Eliminar';
                deleteButton.addEventListener('click', deleteTask);
                actionsDiv.appendChild(deleteButton);

                // Botón Guardar en Registro
                const saveRegistroButton = document.createElement('button');
                saveRegistroButton.classList.add('btn-guardar-registro-icon');
                saveRegistroButton.dataset.id = tarea.id;
                saveRegistroButton.title = 'Guardar en Registro';
                saveRegistroButton.innerHTML = '<i class="fas fa-save"></i>'; // Icono de guardar
                saveRegistroButton.addEventListener('click', () => saveTaskToRegistro(tarea.id));
                actionsDiv.appendChild(saveRegistroButton);

                li.appendChild(actionsDiv);

                if (tarea.completada) {
                    tareasCompletadasList.appendChild(li);
                } else {
                    tareasPendientesList.appendChild(li);
                }
            });

            // Después de renderizar las tareas, inicia o reinicia el intervalo de actualización
            if (timeLeftUpdateInterval) {
                clearInterval(timeLeftUpdateInterval);
            }
            // Actualiza los contadores cada minuto (60 segundos)
            timeLeftUpdateInterval = setInterval(updateAllTimeLeftCounters, 60 * 1000); 
            updateAllTimeLeftCounters(); // Llama una vez inmediatamente
        }

        tareaForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const texto = tareaInput.value.trim();
            const hora = horaInput.value.trim();

            if (!texto) {
                alert('El texto de la tarea no puede estar vacío.');
                return;
            }

            const fecha = formatFecha(fechaActual);

            try {
                const response = await fetch('/api/tareas', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ fecha, texto, hora }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Error desconocido al guardar la tarea.');
                }

                tareaInput.value = '';
                horaInput.value = '';
                fetchTareas(); // Vuelve a cargar las tareas para actualizar la lista
            } catch (error) {
                console.error('Error al guardar la tarea:', error);
                alert(`No se pudo guardar la tarea. Inténtalo de nuevo. Error: ${error.message}`);
            }
        });

        async function toggleTaskCompletada(event) {
            const taskId = event.target.dataset.id;
            try {
                const response = await fetch(`/api/tareas/${taskId}/toggle_completada`, {
                    method: 'PATCH',
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Error desconocido al actualizar la tarea.');
                }
                fetchTareas(); // Recarga las tareas para actualizar la lista
            } catch (error) {
                console.error('Error al cambiar estado:', error);
                alert(`No se pudo actualizar la tarea. Error: ${error.message}`);
            }
        }

        async function deleteTask(event) {
            const taskId = event.target.dataset.id;
            if (confirm('¿Estás seguro de que quieres eliminar esta tarea?')) {
                try {
                    const response = await fetch(`/api/tareas/${taskId}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Error al eliminar la tarea');
                    }
                    fetchTareas(); // Recarga las tareas
                } catch (error) {
                    console.error('Error al eliminar la tarea:', error);
                    alert(`No se pudo eliminar la tarea: ${error.message}`);
                }
            }
        }

        // --- FUNCIÓN PARA CALCULAR Y ACTUALIZAR EL TIEMPO RESTANTE (CORREGIDA) ---
        function updateTimeLeft(taskId, taskDate, taskTime) {
            const targetElement = document.querySelector(`.time-left[data-task-id="${taskId}"]`);
            if (!targetElement || targetElement.closest('.task-item').classList.contains('completada')) {
                return;
            }

            const now = new Date();
            // Si no hay hora, asumimos el final del día (23:59:59) para la cuenta regresiva
            // Esto asegura que las tareas sin hora se consideren "vencidas" al final del día
            const taskDateTimeStr = taskDate + (taskTime ? ' ' + taskTime : ' 23:59:59');
            const taskMoment = new Date(taskDateTimeStr);

            if (taskMoment < now) {
                targetElement.textContent = '(Vencida)';
                targetElement.style.color = '#dc3545'; // Rojo
                targetElement.closest('.task-item').querySelector('.task-text').classList.add('vencida');
                return;
            }

            const diffMs = taskMoment - now; // Diferencia en milisegundos

            const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

            let timeLeftText = '';
            if (days > 0) {
                // Solo días si hay 1 o más días
                timeLeftText = `(${days} día${days !== 1 ? 's' : ''})`;
            } else if (hours > 0) {
                // Horas y minutos si hay horas pero no días
                timeLeftText = `(${hours}h ${minutes}m)`;
            } else if (minutes > 0) {
                // Solo minutos si hay minutos pero no horas ni días
                timeLeftText = `(${minutes}m)`;
            } else {
                // Menos de 1 minuto
                timeLeftText = '(Menos de 1m)';
            }

            targetElement.textContent = timeLeftText;
            targetElement.style.color = '#007bff'; // Azul
            targetElement.closest('.task-item').querySelector('.task-text').classList.remove('vencida');
        }

        // Función para actualizar todos los contadores de tiempo restante visibles
        function updateAllTimeLeftCounters() {
            const activeTasksTimeSpans = document.querySelectorAll('.task-item:not(.completada) .time-left');
            activeTasksTimeSpans.forEach(span => {
                const taskId = span.dataset.taskId;
                const taskDate = span.dataset.taskDate;
                const taskTime = span.dataset.taskTime;
                updateTimeLeft(taskId, taskDate, taskTime);
            });
        }

        // --- FUNCIONES PARA LA MODAL DE REGISTRO ---
        async function saveTaskToRegistro(taskId) {
            const taskElement = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (!taskElement) {
                console.error("Error: taskElement no encontrado para taskId:", taskId);
                alert('No se pudo encontrar la tarea para guardar. Intenta de nuevo.');
                return;
            }

            const fecha = taskElement.dataset.fecha;
            const textoOriginal = taskElement.dataset.textoOriginal;
            const horaOriginal = taskElement.dataset.horaOriginal;
            
            const formContent = document.createElement('div');
            formContent.innerHTML = `
                <h3>Guardar en Registro Importante</h3>
                <label for="registroTitulo">Título:</label>
                <input type="text" id="registroTitulo" value="${textoOriginal}" required>

                <label for="registroDescripcion">Descripción:</label>
                <textarea id="registroDescripcion">Original: "${textoOriginal}"${horaOriginal ? ` (Hora: ${horaOriginal})` : ''}</textarea>

                <label for="registroTipo">Tipo:</label>
                <select id="registroTipo">
                    <option value="Salud">Salud</option>
                    <option value="Cita">Cita</option>
                    <option value="Escolar">Escolar</option>
                    <option value="General" selected>General</option>
                    <option value="Personal">Personal</option>
                    <option value="Finanzas">Finanzas</option>
                    <option value="Documento">Documento</option>
                </select>

                <div class="modal-actions">
                    <button id="guardarRegistroBtn" class="boton">Guardar</button>
                    <button id="cancelRegistroBtn" class="boton cancel-button">Cancelar</button>
                </div>
            `;

            const modal = createModal(formContent);
            document.body.appendChild(modal);

            document.getElementById('guardarRegistroBtn').addEventListener('click', async () => {
                const titulo = document.getElementById('registroTitulo').value.trim();
                const descripcion = document.getElementById('registroDescripcion').value.trim();
                const tipo = document.getElementById('registroTipo').value;

                if (!titulo) {
                    alert('El título es obligatorio.');
                    return;
                }

                try {
                    const response = await fetch('/api/registros_importantes/add_from_task', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ fecha, titulo, descripcion, tipo })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Error desconocido al guardar el registro.');
                    }
                    alert('Registro guardado con éxito.');
                    modal.remove();
                } catch (error) {
                    console.error('Error al guardar el registro:', error);
                    alert(`No se pudo guardar el registro: ${error.message}`);
                }
            });

            document.getElementById('cancelRegistroBtn').addEventListener('click', () => {
                modal.remove();
            });
        }

        function createModal(content) {
            const modalOverlay = document.createElement('div');
            modalOverlay.classList.add('custom-modal-overlay');

            const modalContent = document.createElement('div');
            modalContent.classList.add('custom-modal-content');
            modalContent.appendChild(content);

            modalOverlay.appendChild(modalContent);

            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.remove();
                }
            });

            return modalOverlay;
        }

        // --- Inicialización al cargar la página ---
        document.addEventListener('DOMContentLoaded', () => {
            displayFechaActual(); // Muestra la fecha actual
            fetchTareas(); // Carga las tareas para la fecha actual
            
            // El intervalo de actualización se gestiona en renderTareas para asegurar que se reinicie correctamente
        });
    </script>
</body>
</html>