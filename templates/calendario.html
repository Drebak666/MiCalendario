<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calendario</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
    <div class="calendar-container">
        <div class="calendar-header">
            <div class="month-navigation">
                <button id="prevMonth" class="boton">←</button>
                <h2 id="currentMonthYear"></h2>
                <button id="nextMonth" class="boton">→</button>
            </div>
            <div class="year-selection">
                <label for="yearSelect" style="display: none;">Año:</label>
                <select id="yearSelect"></select>
                <button id="todayButton" class="boton">Hoy</button>
            </div>
        </div>
        <div class="calendar-body" id="calendarDays">
            <div class="day-name">Dom</div>
            <div class="day-name">Lun</div>
            <div class="day-name">Mar</div>
            <div class="day-name">Mié</div>
            <div class="day-name">Jue</div>
            <div class="day-name">Vie</div>
            <div class="day-name">Sáb</div>
        </div>

        <div class="task-form-container">
            <h3>Añadir nueva tarea para el día seleccionado</h3>
            <form id="calendarTaskForm">
                <input type="text" id="calendarTaskInput" placeholder="Añadir una nueva tarea..." required>
                <input type="time" id="calendarTimeInput">
                <button type="submit" class="boton">Guardar Tarea</button>
            </form>
        </div>

        <div class="list-section">
            <h2 id="tasksForSelectedDayHeader">Tareas para el día seleccionado:</h2>
            <ul id="taskList">
            </ul>
        </div>

        <a href="/" class="boton back-button">Volver a Inicio</a>
    </div>

    <script>
        const currentMonthYear = document.getElementById('currentMonthYear');
        const calendarDays = document.getElementById('calendarDays');
        const taskList = document.getElementById('taskList');
        const prevMonth = document.getElementById('prevMonth');
        const nextMonth = document.getElementById('nextMonth');
        const yearSelect = document.getElementById('yearSelect');
        const todayButton = document.getElementById('todayButton');

        const calendarTaskForm = document.getElementById('calendarTaskForm');
        const calendarTaskInput = document.getElementById('calendarTaskInput');
        const calendarTimeInput = document.getElementById('calendarTimeInput');
        const tasksForSelectedDayHeader = document.getElementById('tasksForSelectedDayHeader');

        let currentDate = new Date();
        let selectedDate = null;
        let timeLeftUpdateInterval; // Variable global para el intervalo de actualización

        // Función para formatear la fecha a YYYY-MM-DD
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Rellenar el selector de años
        function populateYearSelect() {
            const currentYear = new Date().getFullYear();
            yearSelect.innerHTML = '';
            for (let i = currentYear - 5; i <= currentYear + 10; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                yearSelect.appendChild(option);
            }
            yearSelect.value = currentDate.getFullYear();
        }

        // Función para renderizar el calendario
        async function renderCalendar(isInitialLoad = false) {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth(); // 0-11
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startDayOfWeek = firstDay.getDay(); // 0 (domingo) - 6 (sábado)

            const monthNames = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"];
            currentMonthYear.textContent = `${monthNames[month]} ${year}`;
            
            yearSelect.value = year;

            // Limpiar los días del calendario, manteniendo los nombres de los días de la semana
            const dayNameElements = Array.from(calendarDays.children).filter(child => child.classList.contains('day-name'));
            calendarDays.innerHTML = ''; // Limpia todo
            dayNameElements.forEach(dayName => calendarDays.appendChild(dayName)); // Vuelve a añadir los nombres

            // Añadir días vacíos al principio si el mes no empieza en domingo
            for (let i = 0; i < startDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.classList.add('day', 'empty');
                calendarDays.appendChild(emptyDay);
            }

            // Añadir los días del mes
            for (let i = 1; i <= daysInMonth; i++) {
                const day = document.createElement('div');
                day.classList.add('day');
                day.textContent = i;
                const fullDate = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                day.dataset.date = fullDate; // Formato YYYY-MM-DD
                day.addEventListener('click', selectDay);
                calendarDays.appendChild(day);
            }

            // Marcar los días que tienen tareas y/o registros
            await markDaysWithTasksAndRegistros(year, month);

            // Determinar qué día seleccionar inicialmente
            const todayFormatted = formatDate(new Date());
            const currentMonthYearStr = `${year}-${String(month + 1).padStart(2, '0')}`;

            let dayToSelectElement = null;

            if (isInitialLoad || !selectedDate || !selectedDate.startsWith(currentMonthYearStr)) {
                if (todayFormatted.startsWith(currentMonthYearStr)) {
                    dayToSelectElement = document.querySelector(`.day[data-date="${todayFormatted}"]`);
                    selectedDate = todayFormatted;
                } else {
                    selectedDate = null; // No seleccionar ningún día si no es el mes actual
                }
            } else if (selectedDate.startsWith(currentMonthYearStr)) {
                dayToSelectElement = document.querySelector(`.day[data-date="${selectedDate}"]`);
            }
            
            const actualTodayElement = document.querySelector(`.day[data-date="${todayFormatted}"]`);
            if (actualTodayElement) {
                actualTodayElement.classList.add('today');
            }

            if (dayToSelectElement) {
                dayToSelectElement.classList.add('selected');
                await loadTasksForDate(selectedDate); // Cargar tareas para el día seleccionado
                tasksForSelectedDayHeader.textContent = `Tareas para el ${new Date(selectedDate).toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`;
            } else {
                tasksForSelectedDayHeader.textContent = 'Selecciona un día para ver sus tareas:';
                taskList.innerHTML = '<li class="no-tasks">Haz clic en un día del calendario para ver o añadir tareas.</li>';
                // Limpiar el intervalo de actualización si no hay día seleccionado
                if (timeLeftUpdateInterval) {
                    clearInterval(timeLeftUpdateInterval);
                    timeLeftUpdateInterval = null;
                }
            }
        }

        async function markDaysWithTasksAndRegistros(year, month) {
            try {
                const [tasksResponse, registrosResponse] = await Promise.all([
                    fetch(`/api/tareas/dias_con_tareas/${year}/${month + 1}`),
                    fetch(`/api/registros_importantes/dias_con_registros/${year}/${month + 1}`)
                ]);

                if (!tasksResponse.ok) throw new Error('Error al obtener días con tareas');
                if (!registrosResponse.ok) throw new Error('Error al obtener días con registros');

                const daysWithTasks = await tasksResponse.json();
                const daysWithRegistros = await registrosResponse.json();

                const allDaysInMonthElements = document.querySelectorAll(`.day[data-date^="${year}-${String(month + 1).padStart(2, '0')}"]`);

                allDaysInMonthElements.forEach(dayElement => {
                    const date = dayElement.dataset.date;
                    // Limpiamos las clases antes de aplicarlas para evitar duplicados en re-renderizados
                    dayElement.classList.remove('has-tasks', 'has-registros');

                    if (daysWithTasks.includes(date)) {
                        dayElement.classList.add('has-tasks');
                    }
                    if (daysWithRegistros.includes(date)) {
                        dayElement.classList.add('has-registros');
                    }
                });
            } catch (error) {
                console.error('Error al marcar días con tareas y/o registros:', error);
            }
        }

        async function selectDay(event) {
            if (selectedDate) {
                const previousSelected = document.querySelector(`.day[data-date="${selectedDate}"]`);
                if (previousSelected) {
                    previousSelected.classList.remove('selected');
                }
            }

            selectedDate = event.target.dataset.date;
            event.target.classList.add('selected');
            
            tasksForSelectedDayHeader.textContent = `Tareas para el ${new Date(selectedDate).toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`;
            await loadTasksForDate(selectedDate);
        }

        async function loadTasksForDate(date) {
            taskList.innerHTML = '<li class="loading">Cargando tareas...</li>';
            try {
                const response = await fetch(`/api/tareas/${date}`);
                if (!response.ok) {
                    throw new Error('Error al cargar las tareas');
                }
                const tasks = await response.json();
                renderTasks(tasks);
            } catch (error) {
                console.error('Error al cargar las tareas:', error);
                taskList.innerHTML = '<li class="error-message">Error al cargar las tareas.</li>';
            }
        }

        function renderTasks(tasks) {
            taskList.innerHTML = '';
            if (tasks.length === 0) {
                taskList.innerHTML = '<li class="no-tasks">No hay tareas para este día.</li>';
                // Detener el intervalo de actualización si no hay tareas
                if (timeLeftUpdateInterval) {
                    clearInterval(timeLeftUpdateInterval);
                    timeLeftUpdateInterval = null;
                }
                return;
            }

            tasks.sort((a, b) => {
                // Tareas completadas al final
                if (a.completada && !b.completada) return 1;
                if (!a.completada && b.completada) return -1;

                // Luego, por hora (si existe)
                if (a.hora && b.hora) {
                    return a.hora.localeCompare(b.hora);
                }
                if (a.hora) return -1; // Tareas con hora primero
                if (b.hora) return 1;  // Tareas con hora primero
                
                // Si no hay hora, ordenar por texto
                return a.texto.localeCompare(b.texto);
            });

            tasks.forEach(task => {
                const li = document.createElement('li');
                li.classList.add('task-item');
                if (task.completada) {
                    li.classList.add('completada');
                }
                li.dataset.id = task.id;
                li.dataset.fecha = task.fecha;
                li.dataset.textoOriginal = task.texto;
                li.dataset.horaOriginal = task.hora || '';

                // --- Contenedor principal del texto de la tarea y el tiempo restante ---
                const taskContentDiv = document.createElement('div');
                taskContentDiv.classList.add('task-content-wrapper');

                // Span para la hora (si existe) y el texto de la tarea
                const taskTextSpan = document.createElement('span');
                taskTextSpan.classList.add('task-text');
                const horaPrefix = task.hora ? `<span class="task-time">${task.hora} - </span>` : '';
                taskTextSpan.innerHTML = `${horaPrefix}${task.texto}`;

                // Span para el tiempo restante (se llenará en updateTimeLeft)
                const timeLeftSpan = document.createElement('span');
                timeLeftSpan.classList.add('time-left');
                timeLeftSpan.dataset.taskId = task.id;       // Importante para encontrarlo en updateTimeLeft
                timeLeftSpan.dataset.taskDate = task.fecha;
                timeLeftSpan.dataset.taskTime = task.hora || '';

                taskContentDiv.appendChild(taskTextSpan);
                taskContentDiv.appendChild(timeLeftSpan);

                li.appendChild(taskContentDiv);

                // --- Contenedor de acciones (botones) ---
                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('task-actions');

                // Botón Completar/Descompletar
                const completeButton = document.createElement('button');
                completeButton.classList.add('btn-completar');
                completeButton.dataset.id = task.id;
                if (task.completada) {
                    completeButton.textContent = 'Descompletar';
                    completeButton.classList.add('completada');
                } else {
                    completeButton.textContent = 'Completar';
                }
                completeButton.addEventListener('click', toggleTaskCompletada);
                actionsDiv.appendChild(completeButton);

                // Botón Eliminar
                const deleteButton = document.createElement('button');
                deleteButton.classList.add('btn-eliminar');
                deleteButton.dataset.id = task.id;
                deleteButton.textContent = 'Eliminar';
                deleteButton.addEventListener('click', deleteTask);
                actionsDiv.appendChild(deleteButton);

                // Botón Guardar en Registro
                const saveRegistroButton = document.createElement('button');
                saveRegistroButton.classList.add('btn-guardar-registro-icon');
                saveRegistroButton.dataset.id = task.id;
                saveRegistroButton.title = 'Guardar en Registro';
                saveRegistroButton.innerHTML = '<i class="fas fa-save"></i>';
                saveRegistroButton.addEventListener('click', () => saveTaskToRegistro(task.id));
                actionsDiv.appendChild(saveRegistroButton);

                li.appendChild(actionsDiv);

                taskList.appendChild(li);
            });

            // Después de renderizar las tareas, inicia o reinicia el intervalo de actualización
            if (timeLeftUpdateInterval) {
                clearInterval(timeLeftUpdateInterval);
            }
            // Actualiza los contadores cada minuto (60 segundos)
            timeLeftUpdateInterval = setInterval(updateAllTimeLeftCounters, 60 * 1000); 
            updateAllTimeLeftCounters(); // Llama una vez inmediatamente
        }

        calendarTaskForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!selectedDate) {
                alert('Por favor, selecciona un día en el calendario primero.');
                return;
            }
            const texto = calendarTaskInput.value.trim();
            const hora = calendarTimeInput.value.trim();

            if (!texto) {
                alert('El texto de la tarea no puede estar vacío.');
                return;
            }

            try {
                const response = await fetch('/api/tareas', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ fecha: selectedDate, texto, hora }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Error desconocido al guardar la tarea.');
                }

                calendarTaskInput.value = '';
                calendarTimeInput.value = '';
                await loadTasksForDate(selectedDate); // Recarga las tareas para el día seleccionado
                markDaysWithTasksAndRegistros(currentDate.getFullYear(), currentDate.getMonth());
            } catch (error) {
                console.error('Error al guardar la tarea:', error);
                alert(`No se pudo guardar la tarea. Inténtalo de nuevo. Error: ${error.message}`);
            }
        });

        async function toggleTaskCompletada(event) {
            const taskId = event.target.dataset.id;
            try {
                const response = await fetch(`/api/tareas/${taskId}/toggle_completada`, {
                    method: 'PATCH',
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Error desconocido al actualizar la tarea.');
                }
                await loadTasksForDate(selectedDate); // Recarga las tareas para el día seleccionado
            } catch (error) {
                console.error('Error al cambiar estado:', error);
                alert(`No se pudo actualizar la tarea. Error: ${error.message}`);
            }
        }

        async function deleteTask(event) {
            const taskId = event.target.dataset.id;
            if (confirm('¿Estás seguro de que quieres eliminar esta tarea?')) {
                try {
                    const response = await fetch(`/api/tareas/${taskId}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Error al eliminar la tarea');
                    }
                    await loadTasksForDate(selectedDate); // Recarga las tareas
                    markDaysWithTasksAndRegistros(currentDate.getFullYear(), currentDate.getMonth());
                } catch (error) {
                    console.error('Error al eliminar la tarea:', error);
                    alert(`No se pudo eliminar la tarea: ${error.message}`);
                }
            }
        }

        async function saveTaskToRegistro(taskId) {
            const taskElement = document.querySelector(`.task-item[data-id="${taskId}"]`);
            if (!taskElement) {
                console.error("Error: taskElement no encontrado para taskId:", taskId);
                alert('No se pudo encontrar la tarea para guardar. Intenta de nuevo.');
                return;
            }

            const fecha = taskElement.dataset.fecha;
            const textoOriginal = taskElement.dataset.textoOriginal;
            const horaOriginal = taskElement.dataset.horaOriginal;
            
            const formContent = document.createElement('div');
            formContent.innerHTML = `
                <h3>Guardar en Registro Importante</h3>
                <label for="registroTitulo">Título:</label>
                <input type="text" id="registroTitulo" value="${textoOriginal}" required>

                <label for="registroDescripcion">Descripción:</label>
                <textarea id="registroDescripcion">Original: "${textoOriginal}"${horaOriginal ? ` (Hora: ${horaOriginal})` : ''}</textarea>

                <label for="registroTipo">Tipo:</label>
                <select id="registroTipo">
                    <option value="Salud">Salud</option>
                    <option value="Cita">Cita</option>
                    <option value="Escolar">Escolar</option>
                    <option value="General" selected>General</option>
                    <option value="Personal">Personal</option>
                    <option value="Finanzas">Finanzas</option>
                    <option value="Documento">Documento</option>
                </select>

                <div class="modal-actions">
                    <button id="guardarRegistroBtn" class="boton">Guardar</button>
                    <button id="cancelRegistroBtn" class="boton cancel-button">Cancelar</button>
                </div>
            `;

            const modal = createModal(formContent);
            document.body.appendChild(modal);

            document.getElementById('guardarRegistroBtn').addEventListener('click', async () => {
                const titulo = document.getElementById('registroTitulo').value.trim();
                const descripcion = document.getElementById('registroDescripcion').value.trim();
                const tipo = document.getElementById('registroTipo').value;

                if (!titulo) {
                    alert('El título es obligatorio.');
                    return;
                }

                try {
                    const response = await fetch('/api/registros_importantes/add_from_task', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ fecha, titulo, descripcion, tipo })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Error desconocido al guardar el registro.');
                    }
                    alert('Registro guardado con éxito.');
                    modal.remove();
                    markDaysWithTasksAndRegistros(currentDate.getFullYear(), currentDate.getMonth());
                } catch (error) {
                    console.error('Error al guardar el registro:', error);
                    alert(`No se pudo guardar el registro: ${error.message}`);
                }
            });

            document.getElementById('cancelRegistroBtn').addEventListener('click', () => {
                modal.remove();
            });
        }

        function createModal(content) {
            const modalOverlay = document.createElement('div');
            modalOverlay.classList.add('custom-modal-overlay');

            const modalContent = document.createElement('div');
            modalContent.classList.add('custom-modal-content');
            modalContent.appendChild(content);

            modalOverlay.appendChild(modalContent);

            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.remove();
                }
            });

            return modalOverlay;
        }

        prevMonth.addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
        });

        nextMonth.addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
        });

        yearSelect.addEventListener('change', () => {
            currentDate.setFullYear(parseInt(yearSelect.value));
            renderCalendar();
        });

        todayButton.addEventListener('click', () => {
            currentDate = new Date();
            selectedDate = formatDate(currentDate); // Asegura que se selecciona el día de hoy
            renderCalendar(true);
        });

        // Función para calcular y mostrar el tiempo restante de una tarea específica
        function updateTimeLeft(taskId, taskDate, taskTime) {
            const targetElement = document.querySelector(`.time-left[data-task-id="${taskId}"]`);
            if (!targetElement || targetElement.closest('.task-item').classList.contains('completada')) {
                return;
            }

            const now = new Date();
            // Si no hay hora, asumimos el final del día (23:59:59) para la cuenta regresiva
            const taskDateTimeStr = taskDate + (taskTime ? ' ' + taskTime : ' 23:59:59');
            const taskMoment = new Date(taskDateTimeStr);

            if (taskMoment < now) {
                targetElement.textContent = '(Vencida)';
                targetElement.style.color = '#dc3545'; // Rojo
                targetElement.closest('.task-item').querySelector('.task-text').classList.add('vencida');
                return;
            }

            const diffMs = taskMoment - now; // Diferencia en milisegundos

            const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

            let timeLeftText = '';
            if (days > 0) {
                timeLeftText = `(${days} día${days !== 1 ? 's' : ''})`;
            } else if (hours > 0) {
                timeLeftText = `(${hours}h ${minutes}m)`;
            } else if (minutes > 0) {
                timeLeftText = `(${minutes}m)`;
            } else {
                timeLeftText = '(Menos de 1m)'; // Para cuando queden menos de un minuto
            }

            targetElement.textContent = timeLeftText;
            targetElement.style.color = '#007bff'; // Azul
            targetElement.closest('.task-item').querySelector('.task-text').classList.remove('vencida');
        }

        // Función para actualizar todos los contadores de tiempo restante visibles
        function updateAllTimeLeftCounters() {
            const activeTasksTimeSpans = document.querySelectorAll('.task-item:not(.completada) .time-left');
            activeTasksTimeSpans.forEach(span => {
                const taskId = span.dataset.taskId;
                const taskDate = span.dataset.taskDate;
                const taskTime = span.dataset.taskTime;
                updateTimeLeft(taskId, taskDate, taskTime);
            });
        }

        // --- INICIALIZACIÓN PRINCIPAL ---
        document.addEventListener('DOMContentLoaded', () => {
            populateYearSelect();
            renderCalendar(true); // Renderiza el calendario y selecciona el día actual/correspondiente

            // El intervalo de actualización se gestiona en renderTasks para asegurar que se reinicie correctamente
        });
    </script>
</body>
</html>